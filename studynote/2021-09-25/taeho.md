# 5. Separating Responsibilities

## 5.1. Selecting the Target Code Smell

> Open Close Principle : 코드는 확장에는 열려있어야 하고 수정에는 닫혀 있어야 한다.

OCP를 확인하기 위한 질문 리스트

1. 같은 모양을 가지고 있는 함수가 존재하는가?

    다르게 생긴 함수여도 실제로 같은 모양인 함수일 수 있다. 이런 부분들을 반드시 체크하고 불필요한 다름은 지양하자.

    <코드 평가 방법 : Squint Test>

    코드를 화면에 올려놓고 상체를 뒤로 젖힌다. 눈을 최대한 가늘게 뜬다.
    코드의 모양과 코드의 컬러를 확인해라. 
    indentation이 많이 되어있다는 것은 조건문의 중첩을 의미한다. 이해하기 어려운 코드이다. 
    색깔이 너무 많다는 것은 추상화의 레벨을 의미한다. 이 또한 이해하기 어려운 코드이다.
    **코드를 이해하지 않고도 그림처럼 보더라도 코드의 수준을 평가할 수 있다.**

2. 같은 이름을 갖는 인자를 전달받는 함수가 존재하는가?

    같은 인자를 전달받는 함수라면 묶어서 새롭게 클래스를 만드는 것도 좋은 방법이다.

3. 같은 이름을 갖는 인자는 같은 것을 의미하는가?

    만약 같지 않다면 네이밍을 다시 하자.

4. 클래스에 private 키워드를 추가한다면 어디에 추가할 것인가?
5. 클래스를 2개로 나눈다면 어디를 기준으로 나눌 것인가?
6. 메소드 별로 공통적인 조건문이 있는가?
7. 조건부 브랜치가 몇개인가?
8. 메소드에 조건부 이외의 코드가 있는가?
9. 각 메소드가 아규먼트에 의존하는가? (or  클래스 자체에 의존하는가)

    아규먼트에만 의존하는 메소드라면 클래스 안에 포함될 이유가 없다.

9개의 질문 리스트에서 전부 yes가 나온다면, non-object-oriented-pattern 이므로 새로운 방법을 고민해봐야 한다. 새로운 클래스를 만들어 위 질문 리스트에 해당하는 메소드들을 묶는 것이 한 가지 좋은 방법이다.

## 5.2. Extracting Classes

항상 기본타입만으로 정보전달을 하려는 기본타입에 대한 강박관념(*Primitive Obsession*)을 없애자. 이를 해결하기 위한 refactoring recipe는 **"Extract Class"**이다.

Extract Class를 하기로 결정했다면 새로운 클래스의 이름을 선정해야 한다. 기본타입을 대체하기로 한 이 클래스가 정확히 무엇을 하는 클래스인지를 인식하고 클래스의 역할에 맞게 네이밍을 하자.

Extract Class를 할 때는 Martin Fowler의 **"Extract Class refactoroing recipe"**를 사용한다.

1. 새로운 클래스 정의
2. 추출해야 하는 메소드들을 새로운 클래스로 복사
3. 메소드들의 공통된 인자를 클래스 변수로 선언
4. 기존 클래스에서 조금씩 변경하면서 실행
5. 기존 클래스에서 새로운 클래스로 메시지를 전부 포워딩
6. 새로운 클래스의 인자를 delete_me=None 으로 변경 후 테스트
7. 변경 메소드를 부르는 모든 sender에서 인자 삭제 후 테스트

위 프로세스를 믿고 one-line changes를 하자.

위 프로세스대로 전부 변경하면 기존 클래스에는 모든 조건에 자유로워진다. 

## 5.3. Appreciating Immutability

변하는 객체라면 변함을 구현해야지 기존 개체를 없애고 변한 새로운 객체를 만들면 안된다. 인간의 사고에서 자연스러운 방향으로 구현하자.

가득 차 있는 커피를 마셔서 줄어든 커피가 되었을 때 이를 어떻게 구현할 것인가?

1. 가득 차 있는 커피를 없애고 커피 양이 줄어든 커피를 다시 만든다.
2. 가득 차 있는 커피에서 커피를 마셔서 없앤다.

당연히 2로 구현해야 하지만 실제로 많은 프로그래머들이 1을 선택한다.

## 5.4. Assuming Fast Enough

불변성의 이점은 정말 크다. 그러나 불변한 것은 없고 이를 유지하기 위해서는 매번 새로운 객체를 만들어야 한다.

캐싱은 앱의 스피드를 높여주고 코스트를 적게 만들어준다. 그러나 이 또한 쓰지 않는 캐시는 삭제하거나 다시 메시지를 전송하여 새 결과를 저장해야 한다.

캐싱과 가변성은 서로 관련되어 있다.

캐싱없이 빠르게 불변한 객체를 이용하여 모든 것을 구현하자. 그 후에 가변성을 추가하자.

## 5.5. Creating BottleNumbers

Extract Class를 많이 호출한다면 이는 수정해야 할 필요가 있다.

캐싱하자!

## 5.6. Recognizing Liskov Violations

successor라는 이름은 후계자라는 뜻이므로 같은 객체를 반환하는 것이 옳다. 그러나 지금 당장 너무 큰 욕심을 부리지 말고 현재코드에서 해결할 수 있는 방법을 먼저 찾자. successor number를 캐싱하여 새 객체를 생성한다.